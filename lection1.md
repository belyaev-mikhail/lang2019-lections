% Введение в язык Haskell
% Михаил Беляев
% \today

## Haskell

* **Тьюринг-полный** язык программирования
* Основан на идеях диалектов LISP и ML
* Чисто функциональный язык программирования
* Ленивая стратегия выполнения
* Мощный компилятор и вывод типов
* Развитые механизмы полиморфизма

## Тьюринг-полнота

Что такое полнота по Тьюрингу?

Как её доказать?

## Тьюринг-полнота

> **Неформальный способ определения** \
> Работа с бесконечной памятью + в бесконечном времени

. . .

Примеры тьюринг-полных концепций?

## Тьюринг-полнота

> **Тьюринг-полная концепция** \
> Любой известный вам язык программирования --- С, С++, Java, etc.
>
> * Память бесконечная?
> * Время бесконечное?

## Тьюринг-полнота

> **Не тьюринг-полная концепция** \
> Конечный автомат (автомат разбора, автомат Мура, автомат Мили)
>
> * Память бесконечная?
> * Время бесконечное?

## Haskell

* Тьюринг-полный язык программирования
* **Основан на идеях диалектов LISP и ML**
* Чисто функциональный язык программирования
* Ленивая стратегия выполнения
* Мощный компилятор и вывод типов
* Развитые механизмы полиморфизма

## История

См. первую лекцию

## Haskell

* Тьюринг-полный язык программирования
* Основан на идеях диалектов LISP и ML
* **Чисто функциональный язык программирования**
* Ленивая стратегия выполнения
* Мощный компилятор и вывод типов
* Развитые механизмы полиморфизма

## Чистая функция

* Функция и в программном, и в математическом смысле
* Отсутствие побочных эффектов
    * Вывод в файл или консоль
    * Сетевое соединение
    * Системный вызов
    * etc.

. . .

А имеет ли вообще смысл программа без побочных эффектов?

## Последствия

Изменение состояния (глобальных) данных --- это тоже побочный эффект.

$\Rightarrow$ *Нет глобальных переменных*

. . .

Фактически, нет и локальных переменных.

. . .

Переменных вообще нет.

Можно ли программировать без переменных?

##  Последствия

> *Более обще* \
> Нет изменяемого состояния (mutable state).

. . .

Можно ли программировать без изменяемого состояния?

## Функциональный подход

* Функции являются объектами первого порядка
* Функции могут принимать и возвращать функции

. . .

Что из этого доступно в языках, которые вы знаете?

## Анонимные функции (лямбда-выражения)

* Похожи на выражения в лямбда-исчислении
* Имеются во многих языках, в том числе Python, С++11, C#4, Java8
* Вместо имени функции ставится $\lambda$

. . .

``` haskell
    \ x -> x + 1
```

## Каррирование (currying)

* Изобретение приписывается Хаскеллу Карри (Haskell Curry)
* Выражение функций от $n$ параметров как функций от одного параметра

``` haskell
    foo a b c = a + b * c
    foo a = \ b -> \ c -> a + b * c
```

## Haskell

* Тьюринг-полный язык программирования
* Основан на идеях диалектов LISP и ML
* Чисто функциональный язык программирования
* **Ленивая стратегия выполнения**
* Мощный компилятор и вывод типов
* Развитые механизмы полиморфизма

## Ленивая стратегия выполнения

``` Cpp
f(g(),h())
```

Strict (eager) evaluation:

1. Вычисляем `_1 = g()`
2. Вычисляем `_2 = h()`
3. Вычисляем `f(_1, _2)`

Lazy evaluation:

Вычисляем `f(_1, _2)`, если где-то внутри используются значения `_1` или `_2`, вычисляем их

##  Ленивая стратегия выполнения: пример

С++: язык со строгим выполнением

``` Cpp
int f(int p1, int p2) {
    return -p1;
}
int g() {
    return 2;
}
int h() {
    throw SomeNastyError(":-P");
}

f(g(),h()); // throws exception
```

##  Ленивая стратегия выполнения: пример

Haskell: язык с ленивым выполнением

``` haskell
f :: Int -> Int -> Int
f p1 p2 = -p1
g :: Int
g = 2
h :: Int
h = error ":-P"

f g h ==> -2
```

##  Ленивая стратегия выполнения: новая ли это концепция?

В С++ и Java достаточно примеров ленивого выполнения:

* `if` ленивый по определению
    * Если бы это было не так, необходимо было бы:
        + Вычислить ветвь для `true`
        + Вычислить ветвь для `false`
        + Выбрать из двух **результатов** нужный...

##  Ленивая стратегия выполнения: новая ли это концепция?

В С++ и Java достаточно примеров ленивого выполнения:

* Логические операции `&&` и `||`

``` Java
    if(a != null
       && a.length > 1
       && a[1] == 40) {
    // everything is ok
    }
    if(a == null
       || a.length <= 1
       || a[1] == 40) {
    // everything is bad as hell
    }
```

## Стратегии выполнения: более формально

<https://en.wikipedia.org/wiki/Evaluation_strategy>

* Eager evaluation:
    * Call-by-value  
      Вычисляем аргумент до вызова функции и передаём туда его значение
    * Call-by-reference  
      Вычисляем аргумент до вызова функции и передаём в функцию ссылку на него
    * etc.

## Стратегии выполнения: более формально

<https://en.wikipedia.org/wiki/Evaluation_strategy>

* Lazy evaluation:
    * Call-by-name \
      Вычисляем аргумент по мере надобности каждый раз, когда он нужен
    * Call-by-need \
      Вычисляем аргумент в какой-то момент времени до того, как он понадобится, и запоминаем его

##  Haskell

* Тьюринг-полный язык программирования
* Основан на идеях диалектов LISP и ML
* Чисто функциональный язык программирования
* Ленивая стратегия выполнения
* Мощный **компилятор** и **вывод типов**
* Развитые механизмы полиморфизма

##  Средства разработки для языка Haskell

* Компилятор GHC, текущая версия --- 8.8.1
    * Поддержка большинства существующих расширений
    * Входит в т.н. Haskell Platform, <http://www.haskell.org>
* Система пакетов
    * Единая база пакетов --- Hackage
    * Управление (установка и обновление) пакетов утилитой Cabal
* IDE: IntelliJ for Haskell, EclipseFP, Leksah

## Haskell Stack

* Альтернативная утилита сборки `stack`
* Может поставить всё, что угодно, даже компилятор
* Stackage (Stable Hackage)
    - Система snapshot'ов (снимков) над Hackage
    - Более старые версии пакетов, зато всё собирается

## GHC

Запуск в режиме интерпретатора: GHCi

\setmonofont[Scale=0.7]{Fira Mono}

``` haskell
[root@vpupkin ~]$ ghci
GHCi, version 8.4.3: http://www.haskell.org/ghc/  :? for help
Prelude> 2 + 2
4
Prelude> 2 ** 2
4.0
Prelude>
```

\setmonofont[Scale=0.95]{Fira Mono}

##  Вывод типов

* Позволяет не писать тип выражения
* Работает в обе стороны!
* Иногда типы функций могут быть очень сложными, в этом случае может помочь интерпретатор:

``` haskell
    Prelude> s a b c = (a c) (b c)
    Prelude> :t s
    s :: (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
    Prelude>
```

## Каррирование в интерпретаторе

``` haskell
Prelude> foo x y = x + y
Prelude> :t foo
foo :: Num a => a -> a -> a
Prelude> bar = \ x -> \ y -> x + y
Prelude> :t bar
bar :: Num a => a -> a -> a
Prelude> foo 2 3
5
Prelude> bar 2 3
5
```

##  Hello world!

* Ввод-вывод в Haskell связан с побочными эффектами
* Побочные эффекты "спрятаны" под монадой `IO`
* Монады мы будем изучать сильно позже

. . .

* На данный момент можно обойтись функцией `interact`:

``` haskell
      program :: String -> String
      program input = "Hello world"

      main = interact program
```

## `if` в Haskell

Поскольку нет последовательности высказываний, `if` --- это тоже выражение, имеющее значение

Синтаксис: `if x then y else z`

## Факториал в Haskell

``` haskell
fact i = if i <= 1 then 1 else i * fact (i - 1)
```

## Строгая типизация

В языке Haskell *строгая статическая* система типов:

- У всего есть тип, известный в процессе компиляции
- Нет неявных приведений типов

``` Cpp
      double foo(double x);

      int y = 52;
      foo(y);
```


## Строгая типизация

\setmonofont[Scale=0.7]{Fira Mono}

``` haskell
Prelude> let foo :: Double -> Double; foo x = x + 3.14
Prelude> let y :: Integer; y = 42
Prelude> foo y

<interactive>:4:5:
    Couldn't match expected type ‘Double’ with actual type ‘Integer’
    In the first argument of ‘foo’, namely ‘y’
    In the expression: foo y
```

\setmonofont[Scale=0.95]{Fira Mono}

##  Haskell

* Тьюринг-полный язык программирования
* Основан на идеях диалектов LISP и ML
* Чисто функциональный язык программирования
* Ленивая стратегия выполнения
* Мощный компилятор и вывод типов
* **Развитые механизмы полиморфизма**

## Полиморфизм

Что такое полиморфизм в программировании?

. . .

Способность кода работать с разными типами данных

## Виды полиморфизма

Alert: субъективная классификация

- Полиморфизм наследования (привет, ООП!)
    - Виртуальные методы, вот это вот всё
- Параметрический полиморфизм
    - Один код, разные данные
- Ad-hoc полиморфизм
    - Разный код, разные данные, один способ вызова

## Полиморфизм ~~наследования~~выбора

- Он же динамический полиморфизм
- Вообще говоря, не только виртуальные методы
    - Указатели на функции
    - Сами функции
    - Прототипирование
    - etc.

## Параметрический полиморфизм

Любимые всеми generic'и

Где **не** встречается: C, Go

В Haskell/OCaml/F#/etc. по умолчанию всё полиморфное

## Обобщённые типы

Квантор общности --- $\forall$

Пример --- функция `id`, имеющая тип `forall a. a -> a`, сокращённо просто `a -> a`

. . .

``` haskell
Prelude> iden a = a
```

. . .

``` haskell
Prelude> iden a = a
Prelude> :t iden
iden :: t -> t
Prelude> a = 2*2
Prelude> :t iden a
iden a :: Integer
```

## Ad-hoc полиморфизм

В большинстве языков представлен перегрузками функций:

``` Cpp
int f(int);
double f(double);
```

. . .

```
f(x); // f depends on x
```

В haskell **перегрузок нет**!

## А что есть?

Более общий механизм, называемый **классами типов**

## В других функциональных языках

- Ad-hoc полиморфизма нет вовсе
- Есть его замены:
    - Через динамический полиморфизм (LISP)
    - Через параметризуемые модули/импорты (OCaml)

##

![](fig/haskell_logo.png){ width=60% } \hfill ![](fig/QR.svg){ width=20% }

\vfill

<http://kspt.icc.spbstu.ru/course/lang>
<belyaev@kspt.icc.spbstu.ru>

![](fig/kspt.svg){ height=1.5em } ![](fig/polytech_logo.eps){ height=1.5em }
